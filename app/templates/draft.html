{% extends "base.html" %}

{% block title %}Mock Draft - Bleuberry FC's MLS Fantasy Stats{% endblock %}
{% block header_title %}Mock Draft{% endblock %}

{% block extra_css %}
<style>
/* Modern color palette */
:root {
    --primary-green: #1a5f3f;
    --light-green: #2d8f5a;
    --accent-blue: #3498db;
    --success-green: #27ae60;
    --warning-orange: #f39c12;
    --danger-red: #e74c3c;
    --dark-text: #2c3e50;
    --light-text: #7f8c8d;
    --bg-light: #f8f9fa;
    --bg-white: #ffffff;
    --shadow-light: 0 2px 10px rgba(0,0,0,0.08);
    --shadow-medium: 0 4px 20px rgba(0,0,0,0.12);
    --border-radius: 12px;
    --transition: all 0.3s ease;
}

/* Main layout container */
.draft-main-container {
    background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    min-height: calc(100vh - 200px);
    padding: 20px 0;
}

/* Top filters section - compact */
.filters-section {
    background: var(--bg-white);
    border-radius: var(--border-radius);
    padding: 15px;
    margin-bottom: 15px;
    box-shadow: var(--shadow-light);
}

.filters-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 12px;
    align-items: end;
}

.filter-group {
    display: flex;
    flex-direction: column;
}

.filter-group label {
    font-weight: 600;
    color: var(--dark-text);
    margin-bottom: 4px;
    font-size: 0.8rem;
}

.filter-group .form-control,
.filter-group .form-select {
    border: 2px solid #e9ecef;
    border-radius: 6px;
    padding: 6px 10px;
    transition: var(--transition);
    font-size: 0.85rem;
}

.filter-group .form-control:focus,
.filter-group .form-select:focus {
    border-color: var(--accent-blue);
    box-shadow: 0 0 0 0.2rem rgba(52, 152, 219, 0.25);
}

/* Main content layout - optimized */
.draft-content {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 15px;
    max-width: 1400px;
    margin: 0 auto;
    align-items: start;
}

/* Pitch section - compact */
.pitch-section {
    background: var(--bg-white);
    border-radius: var(--border-radius);
    padding: 20px;
    box-shadow: var(--shadow-medium);
    height: fit-content;
}

.pitch-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 12px;
    border-bottom: 2px solid #e9ecef;
}

.pitch-title {
    display: flex;
    align-items: center;
    gap: 10px;
    color: var(--dark-text);
    font-size: 1.5rem;
    font-weight: 700;
    margin: 0;
}

.formation-controls {
    display: flex;
    align-items: center;
    gap: 15px;
}

.formation-select {
    min-width: 150px;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    padding: 8px 12px;
}

.formation-display {
    background: var(--primary-green);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: 600;
    font-size: 1.1rem;
}

/* Soccer pitch - compact */
.soccer-pitch {
    background: linear-gradient(135deg, #2d8f5a 0%, #1a5f3f 100%);
    border-radius: 15px;
    padding: 25px;
    position: relative;
    margin-bottom: 20px;
    box-shadow: var(--shadow-medium);
    overflow: hidden;
}

.soccer-pitch::before {
    content: '';
    position: absolute;
    top: 15px;
    left: 15px;
    right: 15px;
    bottom: 15px;
    border: 3px solid rgba(255, 255, 255, 0.6);
    border-radius: 10px;
    pointer-events: none;
}

.soccer-pitch::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 15px;
    right: 15px;
    height: 2px;
    background: rgba(255, 255, 255, 0.6);
    transform: translateY(-50%);
    pointer-events: none;
}

.pitch-formation {
    display: grid;
    grid-template-rows: repeat(4, 1fr);
    gap: 20px;
    min-height: 400px;
    position: relative;
    z-index: 1;
}

.formation-row {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
}

.position-slot {
    width: 120px;
    height: 120px;
    background: rgba(255, 255, 255, 0.95);
    border: 3px dashed rgba(255, 255, 255, 0.7);
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: var(--transition);
    position: relative;
    backdrop-filter: blur(5px);
}

.position-slot:hover {
    transform: scale(1.05);
    background: rgba(255, 255, 255, 1);
    border-color: var(--accent-blue);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}

.position-slot.filled {
    border-style: solid;
    border-color: var(--success-green);
    background: var(--bg-white);
}

.position-label {
    font-size: 14px;
    font-weight: bold;
    color: var(--primary-green);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    margin-bottom: 2px;
}

.position-slot.filled .position-label {
    display: none;
}

/* Player cards */
.player-card {
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, var(--bg-white) 0%, #f8f9fa 100%);
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: var(--transition);
    position: relative;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    padding: 8px;
    box-sizing: border-box;
    overflow: visible;
}

.player-card:hover {
    transform: scale(1.02);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.player-card.selected-for-swap {
    border: 3px solid var(--accent-blue);
    box-shadow: 0 0 15px rgba(52, 152, 219, 0.5);
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 15px rgba(52, 152, 219, 0.5); }
    50% { box-shadow: 0 0 25px rgba(52, 152, 219, 0.8); }
    100% { box-shadow: 0 0 15px rgba(52, 152, 219, 0.5); }
}

.player-name {
    font-size: 14px;
    font-weight: bold;
    color: var(--dark-text);
    text-align: center;
    line-height: 1.0;
    margin-bottom: 2px;
    word-wrap: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
    max-width: 100%;
    padding: 0 4px;
}

.player-name.medium-name {
    font-size: 12px;
    line-height: 0.9;
}

.player-name.long-name {
    font-size: 10px;
    line-height: 0.85;
    padding: 0 2px;
}

.player-team {
    font-size: 13px;
    color: var(--light-text);
    text-align: center;
    margin-bottom: 1px;
}

.player-cost {
    font-size: 13px;
    font-weight: bold;
    color: var(--success-green);
    text-align: center;
    margin-bottom: 16px;
}

.player-position-badge {
    position: absolute;
    bottom: 3px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--primary-green);
    color: white;
    font-size: 8px;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 10px;
    text-align: center;
    z-index: 5;
    min-width: 24px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.player-position-badge.gk {
    background: #e74c3c;
}

.player-position-badge.def {
    background: #3498db;
}

.player-position-badge.mid {
    background: #f39c12;
}

.player-position-badge.fwd {
    background: #27ae60;
}

.player-remove-btn {
    position: absolute;
    top: -3px;
    right: -3px;
    width: 18px;
    height: 18px;
    background: var(--danger-red);
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: var(--transition);
    z-index: 100;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.player-card:hover .player-remove-btn {
    opacity: 1;
}

.player-remove-btn:hover {
    background: #c0392b;
    transform: scale(1.1);
}

/* Bench section - compact */
.bench-section {
    background: var(--bg-light);
    border-radius: var(--border-radius);
    padding: 15px;
    border: 2px dashed #bdc3c7;
}

.bench-title {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.95rem;
    font-weight: 600;
    color: var(--dark-text);
    margin-bottom: 12px;
}

.bench-slots {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;
}

.bench-slot {
    width: 105px;
    height: 105px;
    background: var(--bg-white);
    border: 2px dashed #bdc3c7;
    border-radius: 18px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: var(--transition);
    position: relative;
}

.bench-slot:hover {
    border-color: var(--accent-blue);
    background: #f8f9fa;
    transform: translateY(-2px);
}

.bench-slot.filled {
    border-style: solid;
    border-color: var(--success-green);
}

.bench-slot .player-card {
    border-radius: 18px;
    height: 100%;
}

/* Team actions - compact design */
.team-actions {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 8px;
    margin-top: 15px;
}

.action-btn {
    padding: 8px 12px;
    border: none;
    border-radius: 6px;
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition);
    font-size: 0.8rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
}

.btn-primary-action {
    background: var(--accent-blue);
    color: white;
}

.btn-primary-action:hover {
    background: #2980b9;
    transform: translateY(-1px);
}

.btn-success-action {
    background: var(--success-green);
    color: white;
}

.btn-success-action:hover {
    background: #229954;
    transform: translateY(-1px);
}

.btn-info-action {
    background: #17a2b8;
    color: white;
}

.btn-info-action:hover {
    background: #138496;
    transform: translateY(-1px);
}

.btn-danger-action {
    background: transparent;
    color: var(--danger-red);
    border: 2px solid var(--danger-red);
}

.btn-danger-action:hover {
    background: var(--danger-red);
    color: white;
    transform: translateY(-1px);
}

/* Side panel - compact layout */
.side-panel {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

/* Budget section - compact design */
.budget-card {
    background: linear-gradient(135deg, var(--accent-blue), #3498db);
    color: white;
    border-radius: var(--border-radius);
    padding: 15px;
    text-align: center;
    box-shadow: var(--shadow-light);
}

.budget-title {
    font-size: 0.9rem;
    font-weight: 600;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
}

.budget-input {
    width: 80px;
    padding: 4px 8px;
    border: none;
    border-radius: 4px;
    text-align: center;
    margin-bottom: 8px;
    font-weight: bold;
    font-size: 0.85rem;
}

.budget-remaining {
    font-size: 1.4rem;
    font-weight: bold;
    margin-bottom: 3px;
}

.budget-remaining.warning {
    color: var(--warning-orange);
}

/* Team summary - compact design */
.summary-card {
    background: var(--bg-white);
    border-radius: var(--border-radius);
    padding: 15px;
    box-shadow: var(--shadow-light);
}

.summary-title {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--dark-text);
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.summary-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px 0;
    border-bottom: 1px solid #f1f2f6;
}

.summary-item:last-child {
    border-bottom: none;
}

.summary-label {
    color: var(--light-text);
    font-size: 0.8rem;
}

.summary-value {
    font-weight: 600;
    color: var(--dark-text);
    font-size: 0.85rem;
}

/* Player pool - optimized for better alignment */
.player-pool-card {
    background: var(--bg-white);
    border-radius: var(--border-radius);
    padding: 15px;
    box-shadow: var(--shadow-light);
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.player-pool-title {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--dark-text);
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.player-table-container {
    flex-grow: 1;
    overflow-y: auto;
    border-radius: 8px;
    border: 1px solid #e9ecef;
    min-height: 400px;
    max-height: calc(100vh - 400px);
}

.player-table {
    width: 100%;
    font-size: 0.8rem;
}

.player-table thead th {
    background: var(--primary-green);
    color: white;
    padding: 8px 6px;
    font-weight: 600;
    position: sticky;
    top: 0;
    z-index: 5;
    font-size: 0.75rem;
}

.player-table thead th.sortable {
    cursor: pointer;
    user-select: none;
    transition: var(--transition);
}

.player-table thead th.sortable:hover {
    background: var(--light-green);
}

.sort-indicator {
    margin-left: 4px;
    font-size: 10px;
}

.sort-indicator::after {
    content: '↕';
    opacity: 0.5;
}

.sort-indicator.asc::after {
    content: '↑';
    opacity: 1;
}

.sort-indicator.desc::after {
    content: '↓';
    opacity: 1;
}

.player-table tbody tr {
    cursor: pointer;
    transition: var(--transition);
}

.player-table tbody tr:hover {
    background: rgba(52, 152, 219, 0.1);
}

.player-table tbody tr.selected {
    background: rgba(39, 174, 96, 0.1);
}

.player-table td {
    padding: 6px 4px;
    border-bottom: 1px solid #f1f2f6;
}

.add-player-btn {
    background: var(--success-green);
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    cursor: pointer;
    transition: var(--transition);
}

.add-player-btn:hover {
    background: #229954;
    transform: scale(1.05);
}

.add-player-btn:disabled {
    background: #95a5a6;
    cursor: not-allowed;
    transform: none;
}

/* Custom modals */
.custom-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
}

.custom-modal.show {
    opacity: 1;
    visibility: visible;
}

.modal-content {
    background: var(--bg-white);
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-medium);
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    transform: scale(0.7);
    transition: transform 0.3s ease;
}

.custom-modal.show .modal-content {
    transform: scale(1);
}

.modal-header {
    padding: 20px 25px;
    border-bottom: 1px solid #e9ecef;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--dark-text);
    margin: 0;
}

.modal-close {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: var(--light-text);
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: var(--transition);
}

.modal-close:hover {
    background: #f8f9fa;
    color: var(--dark-text);
}

.modal-body {
    padding: 25px;
}

.saved-team-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    border: 1px solid #e0e0e0;
    border-radius: 5px;
    margin-bottom: 10px;
    background: #f9f9f9;
}

.saved-team-item:hover {
    background: #f0f0f0;
}

.team-info h6 {
    margin: 0;
    color: var(--dark-text);
}

.team-actions .btn {
    margin-left: 5px;
}

.slot-info {
    text-align: center;
}

.slot-info small {
    font-size: 0.75em;
    line-height: 1.2;
}

.existing-save-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px;
    margin: 5px 0;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    background: #f8f9fa;
}

.existing-save-item:hover {
    background: #e9ecef;
}

/* Responsive design */
@media (max-width: 1200px) {
    .draft-content {
        grid-template-columns: 1fr;
    }
    
    .side-panel {
        flex-direction: row;
        flex-wrap: wrap;
    }
    
    .side-panel > * {
        flex: 1;
        min-width: 250px;
    }
}

@media (max-width: 768px) {
    .filters-grid {
        grid-template-columns: 1fr;
    }
    
    .pitch-header {
        flex-direction: column;
        gap: 15px;
        align-items: stretch;
    }
    
    .formation-controls {
        justify-content: space-between;
    }
    
    .position-slot {
        width: 90px;
        height: 90px;
    }
    
    .bench-slot {
        width: 80px;
        height: 80px;
    }
    
    .team-actions {
        grid-template-columns: 1fr;
    }
    
    .side-panel {
        flex-direction: column;
    }
    
    .budget-remaining {
        font-size: 1.2rem;
    }
    
    .side-panel {
        gap: 10px;
    }
}

@media (max-width: 576px) {
    .pitch-formation {
        gap: 15px;
        min-height: 300px;
    }
    
    .formation-row {
        gap: 10px;
    }
    
    .position-slot {
        width: 75px;
        height: 75px;
    }
    
    .bench-slots {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .player-name {
        font-size: 12px;
    }
    
    .player-team,
    .player-cost {
        font-size: 11px;
    }
    
    .player-position-badge {
        font-size: 7px;
        padding: 1px 4px;
        min-width: 20px;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="draft-main-container">
    <div class="container-fluid">
        <!-- Filters Section -->
        <div class="filters-section">
            <div class="filters-grid">
                <div class="filter-group">
                    <label for="playerSearch">Search Player</label>
                    <input type="text" id="playerSearch" class="form-control" placeholder="Type player name...">
                </div>
                <div class="filter-group">
                    <label for="weekSelect">Week</label>
                    <select id="weekSelect" class="form-select">
                        <option value="">All Season</option>
                        {% for week in available_weeks %}
                        <option value="{{ week }}" {% if week == selected_week %}selected{% endif %}>{{ week }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="filter-group">
                    <label for="positionFilter">Position</label>
                    <select id="positionFilter" class="form-select">
                        <option value="">All Positions</option>
                        <option value="goalkeeper">Goalkeeper</option>
                        <option value="defender">Defender</option>
                        <option value="midfielder">Midfielder</option>
                        <option value="forward">Forward</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="teamFilter">Team</label>
                    <select id="teamFilter" class="form-select">
                        <option value="">All Teams</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="draft-content">
            <!-- Pitch Section -->
            <div class="pitch-section">
                <div class="pitch-header">
                    <h2 class="pitch-title">
                        <i class="fas fa-futbol"></i>
                        Team Management
                    </h2>
                    <div class="formation-controls">
                        <div class="formation-display" id="formationDisplay">4-4-2</div>
                        <small class="text-muted">Formation adapts to your player swaps</small>
                    </div>
                </div>

                <!-- Soccer Pitch -->
                <div class="soccer-pitch">
                    <div class="pitch-formation" id="pitchFormation">
                        <!-- Formation will be dynamically created here -->
                    </div>
                </div>

                <!-- Bench -->
                <div class="bench-section">
                    <h3 class="bench-title">
                        <i class="fas fa-chair"></i>
                        Bench (4 Players)
                    </h3>
                    <div class="bench-slots" id="benchSlots">
                        <!-- Bench slots will be created here -->
                    </div>
                </div>

                <!-- Team Actions -->
                <div class="team-actions">
                    <button class="action-btn btn-primary-action" id="autoFillTeam">
                        <i class="fas fa-magic"></i>
                        Auto-Fill
                    </button>
                    <button class="action-btn btn-success-action" id="saveTeam">
                        <i class="fas fa-save"></i>
                        Save
                    </button>
                    <button class="action-btn btn-info-action" id="loadTeam">
                        <i class="fas fa-folder-open"></i>
                        Load
                    </button>
                    <button class="action-btn btn-danger-action" id="clearTeam">
                        <i class="fas fa-trash"></i>
                        Clear
                    </button>
                </div>
            </div>

            <!-- Side Panel -->
            <div class="side-panel">
                <!-- Budget Card -->
                <div class="budget-card">
                    <h3 class="budget-title">
                        <i class="fas fa-coins"></i>
                        Budget
                    </h3>
                    <input type="number" class="budget-input" id="budgetInput" value="100" min="10" max="500" step="5">
                    <div class="budget-remaining" id="budgetRemaining">$100.0M</div>
                    <div>Remaining</div>
                </div>

                <!-- Team Summary -->
                <div class="summary-card">
                    <h3 class="summary-title">
                        <i class="fas fa-clipboard-list"></i>
                        Team Summary
                    </h3>
                    <div class="summary-item">
                        <span class="summary-label">Players</span>
                        <span class="summary-value" id="playerCount">0/15</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Starting XI</span>
                        <span class="summary-value" id="pitchCount">0/11</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Bench</span>
                        <span class="summary-value" id="benchCount">0/4</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Salary Used</span>
                        <span class="summary-value" id="salaryUsed">$0</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Projected Points</span>
                        <span class="summary-value" id="projectedPoints">0</span>
                    </div>
                </div>

                <!-- Player Pool -->
                <div class="player-pool-card">
                    <h3 class="player-pool-title">
                        <i class="fas fa-users"></i>
                        Available Players
                    </h3>
                    <div class="player-table-container">
                        <table class="player-table">
                            <thead>
                                <tr>
                                    <th class="sortable" data-sort="name">Name <span class="sort-indicator"></span></th>
                                    <th>Team</th>
                                    <th>Pos</th>
                                    <th>Cost</th>
                                    <th class="sortable" data-sort="points">Pts <span class="sort-indicator"></span></th>
                                    <th class="sortable" data-sort="average">Avg <span class="sort-indicator"></span></th>
                                    <th class="sortable" data-sort="high">High <span class="sort-indicator"></span></th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody id="playersTableBody">
                                <!-- Players will be populated here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Save Team Modal -->
<div id="saveTeamModal" class="custom-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Save Team</h3>
            <button class="modal-close" onclick="draft.closeSaveModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div class="mb-3">
                <label for="teamName" class="form-label">Team Name:</label>
                <input type="text" class="form-control" id="teamName" placeholder="Enter team name (e.g., 'My 5-3-2 Squad')">
            </div>
            <div class="mb-3">
                <label class="form-label">Save to slot:</label>
                <div class="row">
                    <div class="col-4 mb-2"><button class="btn btn-outline-primary w-100 save-slot-btn" data-slot="1">Slot 1</button></div>
                    <div class="col-4 mb-2"><button class="btn btn-outline-primary w-100 save-slot-btn" data-slot="2">Slot 2</button></div>
                    <div class="col-4 mb-2"><button class="btn btn-outline-primary w-100 save-slot-btn" data-slot="3">Slot 3</button></div>
                    <div class="col-4 mb-2"><button class="btn btn-outline-primary w-100 save-slot-btn" data-slot="4">Slot 4</button></div>
                    <div class="col-4 mb-2"><button class="btn btn-outline-primary w-100 save-slot-btn" data-slot="5">Slot 5</button></div>
                    <div class="col-4 mb-2"><button class="btn btn-outline-primary w-100 save-slot-btn" data-slot="6">Slot 6</button></div>
                </div>
            </div>
            <div id="savedTeams" class="mt-3">
                <!-- Existing saves will be shown here -->
            </div>
        </div>
    </div>
</div>

<!-- Load Team Modal -->
<div id="loadTeamModal" class="custom-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Load Team</h3>
            <button class="modal-close" onclick="draft.closeLoadModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div id="loadTeamsList">
                <!-- Saved teams will be listed here -->
            </div>
            <div class="border-top pt-3 mt-2 text-center" id="clearAllSavesContainer">
                <button class="btn btn-outline-danger btn-sm" onclick="draft.clearAllSaves()">
                    <i class="fas fa-trash"></i> Clear All Saves
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/init.js') }}"></script>
<script>
let playersData = {{ data | tojson }};
let selectedPlayers = [];
let totalBudget = 100.0;
let usedBudget = 0;

const SQUAD_LIMITS = {
    goalkeeper: 2,
    defender: 5,
    midfielder: 5,
    forward: 3
};

const PITCH_CONSTRAINTS = {
    goalkeeper: { min: 1, max: 1 },
    defender: { min: 3, max: 5 },
    midfielder: { min: 3, max: 5 },
    forward: { min: 1, max: 3 }
};

class DraftManager {
    constructor() {
        this.pitchPlayers = [];
        this.benchPlayers = [];
        this.selectedPlayer = null;
        this.currentSort = { column: null, direction: 'asc' };
        this.originalPlayersData = [...playersData];
        this.formations = [
            { name: '3-5-2', pitch: { gk: 1, def: 3, mid: 5, fwd: 2 }, bench: { gk: 1, def: 2, mid: 0, fwd: 1 } },
            { name: '3-4-3', pitch: { gk: 1, def: 3, mid: 4, fwd: 3 }, bench: { gk: 1, def: 2, mid: 1, fwd: 0 } },
            { name: '4-5-1', pitch: { gk: 1, def: 4, mid: 5, fwd: 1 }, bench: { gk: 1, def: 1, mid: 0, fwd: 2 } },
            { name: '4-4-2', pitch: { gk: 1, def: 4, mid: 4, fwd: 2 }, bench: { gk: 1, def: 1, mid: 1, fwd: 1 } },
            { name: '4-3-3', pitch: { gk: 1, def: 4, mid: 3, fwd: 3 }, bench: { gk: 1, def: 1, mid: 2, fwd: 0 } },
            { name: '5-4-1', pitch: { gk: 1, def: 5, mid: 4, fwd: 1 }, bench: { gk: 1, def: 0, mid: 1, fwd: 2 } },
            { name: '5-3-2', pitch: { gk: 1, def: 5, mid: 3, fwd: 2 }, bench: { gk: 1, def: 0, mid: 2, fwd: 1 } }
        ];
        this.currentFormation = this.formations[3];
        
        this.initializeTable();
        this.createFormation();
        this.createBenchSlots();
        this.bindEvents();
        this.updateTeamSummary();
        this.populateTeamFilter();
        this.initializeSorting();
    }

    initializeSorting() {
        const sortableHeaders = document.querySelectorAll('th.sortable');
        sortableHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const sortColumn = header.dataset.sort;
                this.sortTable(sortColumn);
            });
        });
    }

    sortTable(column) {
        // Toggle direction if same column, otherwise default to descending for numeric columns
        if (this.currentSort.column === column) {
            this.currentSort.direction = this.currentSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
            this.currentSort.direction = (column === 'name') ? 'asc' : 'desc';
        }
        this.currentSort.column = column;

        // Sort the data
        playersData.sort((a, b) => {
            let valueA, valueB;
            
            switch(column) {
                case 'name':
                    valueA = (a['Name'] || '').toLowerCase();
                    valueB = (b['Name'] || '').toLowerCase();
                    break;
                case 'points':
                    valueA = parseFloat(a['Total Points'] || 0);
                    valueB = parseFloat(b['Total Points'] || 0);
                    break;
                case 'average':
                    valueA = parseFloat(a['Average Points'] || 0);
                    valueB = parseFloat(b['Average Points'] || 0);
                    break;
                case 'high':
                    valueA = parseFloat(a['High Score'] || 0);
                    valueB = parseFloat(b['High Score'] || 0);
                    break;
                default:
                    return 0;
            }

            if (this.currentSort.direction === 'asc') {
                return valueA < valueB ? -1 : valueA > valueB ? 1 : 0;
            } else {
                return valueA > valueB ? -1 : valueA < valueB ? 1 : 0;
            }
        });

        // Update sort indicators
        this.updateSortIndicators();
        
        // Re-render table with current filters
        this.initializeTable();
        this.filterPlayers();
    }

    updateSortIndicators() {
        // Clear all indicators
        document.querySelectorAll('.sort-indicator').forEach(indicator => {
            indicator.className = 'sort-indicator';
        });

        // Set current sort indicator
        if (this.currentSort.column) {
            const currentHeader = document.querySelector(`th[data-sort="${this.currentSort.column}"] .sort-indicator`);
            if (currentHeader) {
                currentHeader.className = `sort-indicator ${this.currentSort.direction}`;
            }
        }
    }

    initializeTable() {
        const tbody = document.getElementById('playersTableBody');
        tbody.innerHTML = '';
        
        playersData.forEach((player, index) => {
            const cost = this.parseCost(player['Cost'] || '$0.0M');
            player.cost = cost;
            player.id = `player_${index}`;
            
            const row = document.createElement('tr');
            row.className = 'player-row';
            row.dataset.playerIndex = index;
            
            row.innerHTML = `
                <td>${player['Name'] || ''}</td>
                <td>${player['Team'] || ''}</td>
                <td>${this.getPositionShort(player['Positions'] || '')}</td>
                <td style="color: var(--success-green); font-weight: 600;">${player['Cost'] || '$0.0M'}</td>
                <td style="font-weight: 600;">${player['Total Points'] || 0}</td>
                <td style="font-weight: 600;">${player['Average Points'] || 0}</td>
                <td style="font-weight: 600;">${player['High Score'] || 0}</td>
                <td><button class="add-player-btn" onclick="draft.addPlayer(${index})">Add</button></td>
            `;
            
            tbody.appendChild(row);
        });
    }

    parseCost(costStr) {
        const match = costStr.match(/\$(\d+\.\d+)M/);
        return match ? parseFloat(match[1]) : 0.0;
    }

    getPositionShort(position) {
        const pos = position.toLowerCase();
        if (pos.includes('goalkeeper')) return 'GK';
        if (pos.includes('defender')) return 'DEF';
        if (pos.includes('midfielder')) return 'MID';
        if (pos.includes('forward')) return 'FWD';
        return '';
    }

    getPositionForSlot(position) {
        const pos = position.toLowerCase();
        if (pos.includes('goalkeeper')) return 'goalkeeper';
        if (pos.includes('defender')) return 'defender';
        if (pos.includes('midfielder')) return 'midfielder';
        if (pos.includes('forward')) return 'forward';
        return '';
    }

    createFormation() {
        const pitchFormation = document.getElementById('pitchFormation');
        pitchFormation.innerHTML = '';
        
        const formation = this.currentFormation.pitch;
        const rows = [
            { positions: Array(formation.fwd).fill('forward'), label: 'FWD' },
            { positions: Array(formation.mid).fill('midfielder'), label: 'MID' },
            { positions: Array(formation.def).fill('defender'), label: 'DEF' },
            { positions: Array(formation.gk).fill('goalkeeper'), label: 'GK' }
        ];
        
        rows.forEach((row) => {
            const rowDiv = document.createElement('div');
            rowDiv.className = 'formation-row';
            
            row.positions.forEach((position) => {
                const slot = document.createElement('div');
                slot.className = 'position-slot';
                slot.dataset.position = position;
                slot.dataset.location = 'pitch';
                
                const label = document.createElement('div');
                label.className = 'position-label';
                label.textContent = row.label;
                slot.appendChild(label);
                
                this.makeClickable(slot);
                rowDiv.appendChild(slot);
            });
            
            pitchFormation.appendChild(rowDiv);
        });
    }

    createBenchSlots() {
        const benchSlots = document.getElementById('benchSlots');
        benchSlots.innerHTML = '';
        
        // GK slot
        const gkSlot = document.createElement('div');
        gkSlot.className = 'bench-slot';
        gkSlot.dataset.position = 'goalkeeper';
        gkSlot.dataset.location = 'bench';
        gkSlot.innerHTML = '<div class="position-label">GK</div>';
        this.makeClickable(gkSlot);
        benchSlots.appendChild(gkSlot);
        
        // 3 generic bench slots
        for (let i = 0; i < 3; i++) {
            const slot = document.createElement('div');
            slot.className = 'bench-slot';
            slot.dataset.position = 'any';
            slot.dataset.location = 'bench';
            slot.innerHTML = '<div class="position-label">BENCH</div>';
            this.makeClickable(slot);
            benchSlots.appendChild(slot);
        }
        
        // Re-place existing players
        const benchPlayers = selectedPlayers.filter(p => p.location === 'bench');
        benchPlayers.forEach(player => {
            const availableSlot = this.findAvailableSlot(player.position, 'bench');
            if (availableSlot) {
                this.placePlayerInSlot(player, availableSlot);
            }
        });
    }

    makeClickable(slot) {
        // Slots don't need click handlers since we use player card clicks
    }

    addPlayer(index) {
        const player = playersData[index];
        
        if (selectedPlayers.find(p => p.index === index)) {
            alert('Player already selected!');
            return;
        }

        if (selectedPlayers.length >= 15) {
            alert('Squad is full! (15 players maximum)');
            return;
        }

        if (usedBudget + player.cost > totalBudget) {
            alert('Not enough budget remaining!');
            return;
        }

        const playerPosition = this.getPositionForSlot(player['Positions'] || '');
        const positionCount = selectedPlayers.filter(p => p.position === playerPosition).length;
        
        if (positionCount >= SQUAD_LIMITS[playerPosition]) {
            alert(`Maximum ${SQUAD_LIMITS[playerPosition]} ${playerPosition}s allowed in squad!`);
            return;
        }

        const playerData = {
            ...player,
            index: index,
            position: playerPosition,
            location: 'bench'
        };

        selectedPlayers.push(playerData);
        usedBudget += player.cost;
        
        // Try to place on pitch first, then bench
        const pitchSlot = this.findAvailableSlot(playerPosition, 'pitch');
        const benchSlot = this.findAvailableSlot(playerPosition, 'bench');
        
        if (pitchSlot) {
            this.placePlayerInSlot(playerData, pitchSlot);
            playerData.location = 'pitch';
        } else if (benchSlot) {
            this.placePlayerInSlot(playerData, benchSlot);
            playerData.location = 'bench';
        }
        
        this.updateTeamSummary();
        this.updatePlayerRowState(index, true);
        this.updateFormationDisplay();
    }

    findAvailableSlot(position, location) {
        // For pitch, find any slot that matches the position type
        if (location === 'pitch') {
            let slots = document.querySelectorAll(`.position-slot[data-position="${position}"][data-location="${location}"]`);
            for (let slot of slots) {
                if (!slot.classList.contains('filled')) {
                    return slot;
                }
            }
        } else {
            // For bench, first try the specific position slot (like GK bench slot)
            let slots = document.querySelectorAll(`.bench-slot[data-position="${position}"][data-location="${location}"]`);
            for (let slot of slots) {
                if (!slot.classList.contains('filled')) {
                    return slot;
                }
            }
            
            // Then try any generic bench slot
            slots = document.querySelectorAll(`.bench-slot[data-position="any"][data-location="${location}"]`);
            for (let slot of slots) {
                if (!slot.classList.contains('filled')) {
                    return slot;
                }
            }
        }
        
        return null;
    }

    placePlayerInSlot(player, slot) {
        slot.classList.add('filled');
        const playerCard = this.createPlayerCard(player);
        
        // Clear existing content
        slot.innerHTML = '';
        slot.appendChild(playerCard);
        player.slotElement = slot;
    }

    removePlayerFromSlot(slot) {
        slot.classList.remove('filled');
        const existingCard = slot.querySelector('.player-card');
        if (existingCard) {
            existingCard.remove();
        }
        
        // Restore position label
        const position = slot.dataset.position;
        const location = slot.dataset.location;
        let labelText = 'SLOT';
        
        if (position === 'goalkeeper') labelText = 'GK';
        else if (position === 'defender') labelText = 'DEF';
        else if (position === 'midfielder') labelText = 'MID';
        else if (position === 'forward') labelText = 'FWD';
        else if (position === 'any') labelText = 'BENCH';
        
        slot.innerHTML = `<div class="position-label">${labelText}</div>`;
    }

    createPlayerCard(player) {
        const card = document.createElement('div');
        card.className = 'player-card';
        card.dataset.playerId = player.id;
        
        const playerName = player['Name'] || '';
        const playerTeam = player['Team'] || '';
        const playerCost = player['Cost'] || '$0.0M';
        
        // Adjust font size based on name length
        let nameClass = 'player-name';
        if (playerName.length > 15) {
            nameClass += ' long-name';
        } else if (playerName.length > 12) {
            nameClass += ' medium-name';
        }
        
        // Get position abbreviation and class
        const positionAbbr = this.getPositionShort(player['Positions'] || '');
        const positionClass = positionAbbr.toLowerCase();
        
        card.innerHTML = `
            <button class="player-remove-btn" onclick="event.stopPropagation(); draft.removePlayer(${player.index})" title="Remove player">&times;</button>
            <div class="player-position-badge ${positionClass}">${positionAbbr}</div>
            <div class="${nameClass}">${playerName}</div>
            <div class="player-team">${playerTeam}</div>
            <div class="player-cost">${playerCost}</div>
        `;
        
        card.addEventListener('click', (e) => {
            if (e.target.classList.contains('player-remove-btn')) {
                return;
            }
            e.stopPropagation();
            this.handlePlayerClick(player);
        });
        
        return card;
    }

    handlePlayerClick(player) {
        if (!this.selectedPlayer) {
            this.selectedPlayer = player;
            const card = player.slotElement.querySelector('.player-card');
            card.classList.add('selected-for-swap');
        } else if (this.selectedPlayer.id === player.id) {
            this.clearSelection();
        } else {
            this.swapPlayers(this.selectedPlayer, player);
            this.clearSelection();
        }
    }

    clearSelection() {
        if (this.selectedPlayer) {
            const card = this.selectedPlayer.slotElement?.querySelector('.player-card');
            if (card) {
                card.classList.remove('selected-for-swap');
            }
            this.selectedPlayer = null;
        }
    }

    swapPlayers(player1, player2) {
        // Store original locations
        const player1Location = player1.location;
        const player2Location = player2.location;
        
        // Check if this swap would violate minimum position requirements
        if (!this.isSwapValid(player1, player2)) {
            const violatedRule = this.getViolatedRule(player1, player2);
            alert(`Cannot perform swap: ${violatedRule}`);
            return;
        }
        
        // Remove both players from their current slots
        this.removePlayerFromSlot(player1.slotElement);
        this.removePlayerFromSlot(player2.slotElement);
        
        // Swap locations but keep their positions
        player1.location = player2Location;
        player2.location = player1Location;
        
        // Find appropriate slots for each player based on their position and new location
        const player1NewSlot = this.findBestSlotForPlayer(player1);
        const player2NewSlot = this.findBestSlotForPlayer(player2);
        
        // Check if we need to change formation to accommodate the swap
        const formationChange = this.getRequiredFormationChange();
        
        if (formationChange !== null) {
            this.changeFormation(formationChange);
            document.getElementById('formationSelect').value = formationChange.toString();
            
            // Re-find slots after formation change
            const newPlayer1Slot = this.findBestSlotForPlayer(player1);
            const newPlayer2Slot = this.findBestSlotForPlayer(player2);
            
            if (newPlayer1Slot) this.placePlayerInSlot(player1, newPlayer1Slot);
            if (newPlayer2Slot) this.placePlayerInSlot(player2, newPlayer2Slot);
        } else {
            // Place players in their best available slots
            if (player1NewSlot) this.placePlayerInSlot(player1, player1NewSlot);
            if (player2NewSlot) this.placePlayerInSlot(player2, player2NewSlot);
        }
        
        this.updateTeamSummary();
        this.updateFormationDisplay();
    }
    
    isSwapValid(player1, player2) {
        // Goalkeepers can only swap with other goalkeepers
        if (player1.position === 'goalkeeper' || player2.position === 'goalkeeper') {
            return player1.position === 'goalkeeper' && player2.position === 'goalkeeper';
        }
        
        // Simulate the swap to check if it would violate minimums for non-goalkeepers
        const currentPitchPlayers = selectedPlayers.filter(p => p.location === 'pitch');
        
        // Create a simulated state after the swap
        const simulatedPitchPlayers = currentPitchPlayers.map(p => {
            if (p.id === player1.id) {
                return { ...p, location: player2.location };
            } else if (p.id === player2.id) {
                return { ...p, location: player1.location };
            }
            return p;
        });
        
        // Add players that would move to pitch
        if (player1.location === 'bench' && player2.location === 'pitch') {
            simulatedPitchPlayers.push({ ...player1, location: 'pitch' });
        }
        if (player2.location === 'bench' && player1.location === 'pitch') {
            simulatedPitchPlayers.push({ ...player2, location: 'pitch' });
        }
        
        // Filter only players that would remain on pitch
        const finalPitchPlayers = simulatedPitchPlayers.filter(p => p.location === 'pitch');
        
        // Count positions on pitch after swap
        const positionCounts = {
            goalkeeper: finalPitchPlayers.filter(p => p.position === 'goalkeeper').length,
            defender: finalPitchPlayers.filter(p => p.position === 'defender').length,
            midfielder: finalPitchPlayers.filter(p => p.position === 'midfielder').length,
            forward: finalPitchPlayers.filter(p => p.position === 'forward').length
        };
        
        // Check minimum requirements
        return positionCounts.goalkeeper >= 1 &&
               positionCounts.defender >= 3 &&
               positionCounts.midfielder >= 3 &&
               positionCounts.forward >= 1;
    }
    
    getViolatedRule(player1, player2) {
        // Check for goalkeeper-specific rule violation
        if (player1.position === 'goalkeeper' || player2.position === 'goalkeeper') {
            if (!(player1.position === 'goalkeeper' && player2.position === 'goalkeeper')) {
                return "Goalkeepers can only be swapped with other goalkeepers";
            }
        }
        
        // Simulate the swap to identify which rule is violated for non-goalkeeper swaps
        const currentPitchPlayers = selectedPlayers.filter(p => p.location === 'pitch');
        
        // Create a simulated state after the swap
        const simulatedPitchPlayers = currentPitchPlayers.map(p => {
            if (p.id === player1.id) {
                return { ...p, location: player2.location };
            } else if (p.id === player2.id) {
                return { ...p, location: player1.location };
            }
            return p;
        });
        
        // Add players that would move to pitch
        if (player1.location === 'bench' && player2.location === 'pitch') {
            simulatedPitchPlayers.push({ ...player1, location: 'pitch' });
        }
        if (player2.location === 'bench' && player1.location === 'pitch') {
            simulatedPitchPlayers.push({ ...player2, location: 'pitch' });
        }
        
        // Filter only players that would remain on pitch
        const finalPitchPlayers = simulatedPitchPlayers.filter(p => p.location === 'pitch');
        
        // Count positions on pitch after swap
        const positionCounts = {
            goalkeeper: finalPitchPlayers.filter(p => p.position === 'goalkeeper').length,
            defender: finalPitchPlayers.filter(p => p.position === 'defender').length,
            midfielder: finalPitchPlayers.filter(p => p.position === 'midfielder').length,
            forward: finalPitchPlayers.filter(p => p.position === 'forward').length
        };
        
        // Return specific violation message
        if (positionCounts.goalkeeper < 1) {
            return "Must have at least 1 goalkeeper on pitch";
        }
        if (positionCounts.defender < 3) {
            return "Must have at least 3 defenders on pitch";
        }
        if (positionCounts.midfielder < 3) {
            return "Must have at least 3 midfielders on pitch";
        }
        if (positionCounts.forward < 1) {
            return "Must have at least 1 forward on pitch";
        }
        
        return "Unknown validation error";
    }
    
    findBestSlotForPlayer(player) {
        // First try to find a slot that matches the player's position and location
        let availableSlot = this.findAvailableSlot(player.position, player.location);
        
        if (availableSlot) {
            return availableSlot;
        }
        
        // If no exact match, try any available slot in the same location (for bench)
        if (player.location === 'bench') {
            availableSlot = this.findAvailableSlot('any', 'bench');
            if (availableSlot) {
                return availableSlot;
            }
        }
        
        return null;
    }
    
    getRequiredFormationChange() {
        // Count players by position on pitch after the swap
        const pitchPlayers = selectedPlayers.filter(p => p.location === 'pitch');
        const positionCounts = {
            goalkeeper: pitchPlayers.filter(p => p.position === 'goalkeeper').length,
            defender: pitchPlayers.filter(p => p.position === 'defender').length,
            midfielder: pitchPlayers.filter(p => p.position === 'midfielder').length,
            forward: pitchPlayers.filter(p => p.position === 'forward').length
        };
        
        // Ensure we have exactly 11 players on pitch (should be maintained during swap)
        const totalPitchPlayers = Object.values(positionCounts).reduce((sum, count) => sum + count, 0);
        if (totalPitchPlayers !== 11) {
            return null; // Don't change formation if player count is wrong
        }
        
        // Check if current formation can accommodate these counts
        const currentFormation = this.currentFormation.pitch;
        
        if (positionCounts.goalkeeper <= currentFormation.gk &&
            positionCounts.defender <= currentFormation.def &&
            positionCounts.midfielder <= currentFormation.mid &&
            positionCounts.forward <= currentFormation.fwd) {
            return null; // No formation change needed
        }
        
        // Find a formation that can accommodate the position counts
        for (let i = 0; i < this.formations.length; i++) {
            const formation = this.formations[i].pitch;
            if (positionCounts.goalkeeper <= formation.gk &&
                positionCounts.defender <= formation.def &&
                positionCounts.midfielder <= formation.mid &&
                positionCounts.forward <= formation.fwd) {
                return i;
            }
        }
        
        // If no formation can accommodate, try to find the best fit
        // Priority: 3-4-3 for more forwards, 5-4-1 for more defenders, 4-5-1 for more midfielders
        if (positionCounts.forward > 2) {
            return 1; // 3-4-3
        } else if (positionCounts.defender > 4) {
            return 5; // 5-4-1
        } else if (positionCounts.midfielder > 4) {
            return 2; // 4-5-1
        }
        
        return 3; // Default to 4-4-2
    }

    removePlayer(index) {
        const playerIndex = selectedPlayers.findIndex(p => p.index === index);
        if (playerIndex === -1) return;

        const player = selectedPlayers[playerIndex];
        
        // Check if removing this player would violate minimum position requirements
        if (player.location === 'pitch' && !this.canRemovePlayerFromPitch(player)) {
            const violationMessage = this.getRemovalViolationMessage(player);
            alert(`Cannot remove player: ${violationMessage}`);
            return;
        }
        
        usedBudget -= player.cost;
        
        if (player.slotElement) {
            this.removePlayerFromSlot(player.slotElement);
        }
        
        selectedPlayers.splice(playerIndex, 1);
        this.updateTeamSummary();
        this.updatePlayerRowState(index, false);
        this.updateFormationDisplay();
    }
    
    canRemovePlayerFromPitch(playerToRemove) {
        // Simulate removing the player
        const remainingPitchPlayers = selectedPlayers.filter(p => 
            p.location === 'pitch' && p.id !== playerToRemove.id
        );
        
        // Count positions that would remain on pitch
        const positionCounts = {
            goalkeeper: remainingPitchPlayers.filter(p => p.position === 'goalkeeper').length,
            defender: remainingPitchPlayers.filter(p => p.position === 'defender').length,
            midfielder: remainingPitchPlayers.filter(p => p.position === 'midfielder').length,
            forward: remainingPitchPlayers.filter(p => p.position === 'forward').length
        };
        
        // Check if minimum requirements would still be met
        return positionCounts.goalkeeper >= 1 &&
               positionCounts.defender >= 3 &&
               positionCounts.midfielder >= 3 &&
               positionCounts.forward >= 1;
    }
    
    getRemovalViolationMessage(playerToRemove) {
        // Simulate removing the player
        const remainingPitchPlayers = selectedPlayers.filter(p => 
            p.location === 'pitch' && p.id !== playerToRemove.id
        );
        
        // Count positions that would remain on pitch
        const positionCounts = {
            goalkeeper: remainingPitchPlayers.filter(p => p.position === 'goalkeeper').length,
            defender: remainingPitchPlayers.filter(p => p.position === 'defender').length,
            midfielder: remainingPitchPlayers.filter(p => p.position === 'midfielder').length,
            forward: remainingPitchPlayers.filter(p => p.position === 'forward').length
        };
        
        // Return specific violation message
        if (positionCounts.goalkeeper < 1) {
            return "Must have at least 1 goalkeeper on pitch";
        }
        if (positionCounts.defender < 3) {
            return "Must have at least 3 defenders on pitch";
        }
        if (positionCounts.midfielder < 3) {
            return "Must have at least 3 midfielders on pitch";
        }
        if (positionCounts.forward < 1) {
            return "Must have at least 1 forward on pitch";
        }
        
        return "Unknown validation error";
    }

    updatePlayerRowState(index, selected) {
        const row = document.querySelector(`tr[data-player-index="${index}"]`);
        if (row) {
            row.classList.toggle('selected', selected);
            const button = row.querySelector('.add-player-btn');
            button.textContent = selected ? 'Added' : 'Add';
            button.disabled = selected;
        }
    }

    updateTeamSummary() {
        const pitchPlayers = selectedPlayers.filter(p => p.location === 'pitch');
        const benchPlayers = selectedPlayers.filter(p => p.location === 'bench');
        
        const remaining = totalBudget - usedBudget;
        const budgetElement = document.getElementById('budgetRemaining');
        budgetElement.textContent = `$${remaining.toFixed(1)}M`;
        budgetElement.classList.toggle('warning', usedBudget > totalBudget);
        
        document.getElementById('playerCount').textContent = `${selectedPlayers.length}/15`;
        document.getElementById('pitchCount').textContent = `${pitchPlayers.length}/11`;
        document.getElementById('benchCount').textContent = `${benchPlayers.length}/4`;
        document.getElementById('salaryUsed').textContent = `$${usedBudget.toFixed(1)}M`;
        
        const projectedPoints = selectedPlayers.reduce((sum, player) => 
            sum + parseFloat(player['Total Points'] || 0), 0);
        document.getElementById('projectedPoints').textContent = projectedPoints.toFixed(1);
        
        const budgetInput = document.getElementById('budgetInput');
        if (budgetInput && parseFloat(budgetInput.value) !== totalBudget) {
            totalBudget = parseFloat(budgetInput.value) || 100.0;
        }
    }

    clearTeam() {
        if (selectedPlayers.length === 0) return;
        
        if (confirm('Are you sure you want to clear your entire team?')) {
            selectedPlayers.forEach(player => {
                if (player.slotElement) {
                    this.removePlayerFromSlot(player.slotElement);
                }
                this.updatePlayerRowState(player.index, false);
            });
            
            selectedPlayers = [];
            usedBudget = 0;
            this.updateTeamSummary();
        }
    }

    showSaveModal() {
        if (selectedPlayers.length !== 15) {
            alert('Please select exactly 15 players before saving!');
            return;
        }
        
        const pitchPlayers = selectedPlayers.filter(p => p.location === 'pitch');
        const benchPlayers = selectedPlayers.filter(p => p.location === 'bench');
        
        if (pitchPlayers.length !== 11 || benchPlayers.length !== 4) {
            alert('Please have exactly 11 players on pitch and 4 on bench!');
            return;
        }

        this.updateSaveModal();
        const modal = document.getElementById('saveTeamModal');
        modal.classList.add('show');
        
        setTimeout(() => {
            document.getElementById('teamName').focus();
        }, 100);
    }

    closeSaveModal() {
        const modal = document.getElementById('saveTeamModal');
        modal.classList.remove('show');
        document.getElementById('teamName').value = '';
    }

    showLoadModal() {
        this.updateLoadModal();
        const modal = document.getElementById('loadTeamModal');
        modal.classList.add('show');
    }

    closeLoadModal() {
        const modal = document.getElementById('loadTeamModal');
        modal.classList.remove('show');
    }

    updateSaveModal() {
        const savedTeams = this.getSavedTeams();
        const saveSlotBtns = document.querySelectorAll('.save-slot-btn');
        
        // Update slot appearance based on whether they're occupied
        saveSlotBtns.forEach(btn => {
            const slot = btn.dataset.slot;
            const existingTeam = savedTeams[slot];
            
            // Remove any existing event listeners
            btn.replaceWith(btn.cloneNode(true));
        });
        
        // Re-query after replacing nodes
        const updatedSaveSlotBtns = document.querySelectorAll('.save-slot-btn');
        updatedSaveSlotBtns.forEach(btn => {
            const slot = btn.dataset.slot;
            const existingTeam = savedTeams[slot];
            
            if (existingTeam) {
                // Slot is occupied
                btn.className = 'btn btn-warning w-100 save-slot-btn';
                btn.innerHTML = `
                    <div class="slot-info">
                        <strong>Slot ${slot} - OCCUPIED</strong>
                        <small class="d-block">${existingTeam.name}</small>
                        <small class="d-block text-muted">${existingTeam.formation} • ${new Date(existingTeam.timestamp).toLocaleDateString()}</small>
                    </div>
                `;
            } else {
                // Slot is empty
                btn.className = 'btn btn-outline-primary w-100 save-slot-btn';
                btn.innerHTML = `Slot ${slot} - EMPTY`;
            }
            
            btn.addEventListener('click', () => {
                const teamName = document.getElementById('teamName').value.trim();
                
                if (!teamName) {
                    alert('Please enter a team name!');
                    return;
                }
                
                // Check if slot is occupied and confirm overwrite
                if (existingTeam) {
                    const confirmOverwrite = confirm(`Slot ${slot} already contains "${existingTeam.name}".\n\nDo you want to overwrite it with "${teamName}"?`);
                    if (!confirmOverwrite) {
                        return;
                    }
                }
                
                this.saveTeamToSlot(slot, teamName);
            });
        });
        
        // Update the saved teams display section
        this.updateSavedTeamsDisplay();
    }
    
    updateSavedTeamsDisplay() {
        const savedTeamsContainer = document.getElementById('savedTeams');
        const savedTeams = this.getSavedTeams();
        
        if (Object.keys(savedTeams).length === 0) {
            savedTeamsContainer.innerHTML = '<p class="text-muted text-center">No saved teams yet.</p>';
            return;
        }
        
        let html = '<h6>Existing Saves:</h6>';
        Object.entries(savedTeams).forEach(([slot, teamData]) => {
            html += `
                <div class="existing-save-item">
                    <span><strong>Slot ${slot}:</strong> ${teamData.name} (${teamData.formation})</span>
                    <button class="btn btn-sm btn-outline-danger" onclick="draft.deleteTeamFromSlot('${slot}'); draft.updateSaveModal();">Delete</button>
                </div>
            `;
        });
        
        savedTeamsContainer.innerHTML = html;
    }

    updateLoadModal() {
        const loadTeamsList = document.getElementById('loadTeamsList');
        const savedTeams = this.getSavedTeams();
        
        if (Object.keys(savedTeams).length === 0) {
            loadTeamsList.innerHTML = '<p class="text-muted text-center py-4">No saved teams found.</p>';
            return;
        }
        
        let html = '';
        Object.entries(savedTeams).forEach(([slot, teamData]) => {
            html += `
                <div class="saved-team-item">
                    <div class="team-info">
                        <h6>${teamData.name}</h6>
                        <small class="text-muted">
                            ${teamData.players.length} players • 
                            Formation: ${teamData.formation} • 
                            Saved: ${new Date(teamData.timestamp).toLocaleDateString()}
                        </small>
                    </div>
                    <div class="team-actions">
                        <button class="btn btn-sm btn-primary" onclick="draft.loadTeamFromSlot('${slot}')">Load</button>
                        <button class="btn btn-sm btn-danger" onclick="draft.deleteTeamFromSlot('${slot}')">Delete</button>
                    </div>
                </div>
            `;
        });
        
        html += `
            <div class="mt-3 text-center">
                <button class="btn btn-sm btn-outline-danger" onclick="draft.clearAllSaves()">Clear All</button>
            </div>
        `;
        
        loadTeamsList.innerHTML = html;
    }

    saveTeamToSlot(slot, teamName) {
        try {
            const savedTeams = this.getSavedTeams();
            
            // Create team data to save
            const teamData = {
                name: teamName,
                formation: this.currentFormation.name,
                players: selectedPlayers.map(player => ({
                    index: player.index,
                    name: player['Name'],
                    position: player.position,
                    location: player.location,
                    cost: player.cost,
                    id: player.id
                })),
                usedBudget: usedBudget,
                totalBudget: totalBudget,
                timestamp: new Date().toISOString(),
                slot: slot
            };
            
            // Save to localStorage
            savedTeams[slot] = teamData;
            localStorage.setItem('draftSavedTeams', JSON.stringify(savedTeams));
            
            alert(`Team "${teamName}" saved successfully!`);
            this.closeSaveModal();
            
        } catch (error) {
            alert('Error saving team. Please try again.');
            console.error('Save error:', error);
        }
    }

    getSavedTeams() {
        const saved = localStorage.getItem('draftSavedTeams');
        return saved ? JSON.parse(saved) : {};
    }

    loadTeamFromSlot(slot) {
        try {
            const savedTeams = this.getSavedTeams();
            const teamData = savedTeams[slot];
            
            if (!teamData) {
                alert('Team not found!');
                return;
            }
            
            // Clear current team without confirmation
            selectedPlayers.forEach(player => {
                if (player.slotElement) {
                    this.removePlayerFromSlot(player.slotElement);
                }
                this.updatePlayerRowState(player.index, false);
            });
            
            selectedPlayers = [];
            usedBudget = 0;
            this.updateTeamSummary();
            
            // Set formation
            const formationIndex = this.formations.findIndex(f => f.name === teamData.formation);
            if (formationIndex !== -1) {
                this.currentFormation = this.formations[formationIndex];
                document.getElementById('formationDisplay').textContent = this.currentFormation.name;
                this.createFormation();
                this.createBenchSlots();
            }
            
            // Load players
            teamData.players.forEach(playerData => {
                this.addPlayer(playerData.index);
            });
            
            // Update budget
            usedBudget = teamData.usedBudget;
            totalBudget = teamData.totalBudget;
            document.getElementById('budgetInput').value = totalBudget;
            
            this.updateTeamSummary();
            this.updateFormationDisplay();
            
            alert(`Team "${teamData.name}" loaded successfully!`);
            this.closeLoadModal();
            
        } catch (error) {
            alert('Error loading team. Please try again.');
            console.error('Load error:', error);
        }
    }
    
    deleteTeamFromSlot(slot) {
        if (confirm('Are you sure you want to delete this saved team?')) {
            try {
                const savedTeams = this.getSavedTeams();
                delete savedTeams[slot];
                localStorage.setItem('draftSavedTeams', JSON.stringify(savedTeams));
                this.updateLoadModal();
                alert('Team deleted successfully!');
            } catch (error) {
                alert('Error deleting team. Please try again.');
                console.error('Delete error:', error);
            }
        }
    }

    clearAllSaves() {
        if (confirm('Are you sure you want to delete all saved teams?')) {
            localStorage.removeItem('draftSavedTeams');
            this.updateLoadModal();
            alert('All saved teams have been deleted.');
        }
    }

    autoFillTeam() {
        if (selectedPlayers.length > 0) {
            if (!confirm('This will clear your current team and auto-fill with new players. Continue?')) {
                return;
            }
            this.clearTeam();
        }

        // Get available budget
        const availableBudget = totalBudget;
        
        // Sort players by value (points per million)
        const sortedPlayers = [...playersData].map(player => {
            const points = parseFloat(player['Total Points'] || 0);
            const cost = player.cost || 0.1; // Avoid division by zero
            return {
                ...player,
                valueRatio: points / cost,
                originalIndex: playersData.indexOf(player)
            };
        }).sort((a, b) => b.valueRatio - a.valueRatio);

        // Define target counts based on current formation
        const formation = this.currentFormation;
        const targets = {
            goalkeeper: formation.pitch.gk + formation.bench.gk,
            defender: formation.pitch.def + formation.bench.def,
            midfielder: formation.pitch.mid + formation.bench.mid,
            forward: formation.pitch.fwd + formation.bench.fwd
        };

        let selectedForAutoFill = [];
        let remainingBudget = availableBudget;
        
        // Auto-fill by position priority
        const positions = ['goalkeeper', 'defender', 'midfielder', 'forward'];
        
        positions.forEach(position => {
            const positionPlayers = sortedPlayers.filter(player => 
                this.getPositionForSlot(player['Positions'] || '') === position
            );
            
            let selectedCount = 0;
            const targetCount = targets[position];
            
            for (let player of positionPlayers) {
                if (selectedCount >= targetCount) break;
                if (player.cost <= remainingBudget) {
                    selectedForAutoFill.push(player);
                    remainingBudget -= player.cost;
                    selectedCount++;
                }
            }
        });

        // If we don't have enough players, fill with cheapest available
        if (selectedForAutoFill.length < 15) {
            const remainingSlots = 15 - selectedForAutoFill.length;
            const availablePlayers = sortedPlayers.filter(player => 
                !selectedForAutoFill.find(selected => selected.originalIndex === player.originalIndex)
            ).sort((a, b) => a.cost - b.cost); // Sort by cost (cheapest first)

            for (let i = 0; i < Math.min(remainingSlots, availablePlayers.length); i++) {
                const player = availablePlayers[i];
                if (player.cost <= remainingBudget) {
                    selectedForAutoFill.push(player);
                    remainingBudget -= player.cost;
                }
            }
        }

        // Add players to the team
        selectedForAutoFill.forEach(player => {
            this.addPlayer(player.originalIndex);
        });

        // Show success message
        if (selectedForAutoFill.length === 15) {
            alert(`Auto-fill completed! Selected ${selectedForAutoFill.length} players within budget of $${availableBudget.toFixed(1)}M. Remaining budget: $${remainingBudget.toFixed(1)}M`);
        } else {
            alert(`Auto-fill completed with ${selectedForAutoFill.length} players due to budget constraints. Consider increasing your budget or manually selecting cheaper players.`);
        }
    }

    updateFormationDisplay() {
        // Count players by position on pitch
        const pitchPlayers = selectedPlayers.filter(p => p.location === 'pitch');
        const positionCounts = {
            goalkeeper: pitchPlayers.filter(p => p.position === 'goalkeeper').length,
            defender: pitchPlayers.filter(p => p.position === 'defender').length,
            midfielder: pitchPlayers.filter(p => p.position === 'midfielder').length,
            forward: pitchPlayers.filter(p => p.position === 'forward').length
        };
        
        // Determine formation based on current pitch composition
        let detectedFormation = '4-4-2'; // Default
        
        if (pitchPlayers.length === 11) {
            const def = positionCounts.defender;
            const mid = positionCounts.midfielder;
            const fwd = positionCounts.forward;
            
            // Map common formations
            if (def === 3 && mid === 5 && fwd === 2) detectedFormation = '3-5-2';
            else if (def === 3 && mid === 4 && fwd === 3) detectedFormation = '3-4-3';
            else if (def === 4 && mid === 5 && fwd === 1) detectedFormation = '4-5-1';
            else if (def === 4 && mid === 4 && fwd === 2) detectedFormation = '4-4-2';
            else if (def === 4 && mid === 3 && fwd === 3) detectedFormation = '4-3-3';
            else if (def === 5 && mid === 4 && fwd === 1) detectedFormation = '5-4-1';
            else if (def === 5 && mid === 3 && fwd === 2) detectedFormation = '5-3-2';
            else {
                // Custom formation - show actual counts
                detectedFormation = `${def}-${mid}-${fwd}`;
            }
        } else {
            // Incomplete team
            detectedFormation = `Building... (${pitchPlayers.length}/11)`;
        }
        
        // Update display
        document.getElementById('formationDisplay').textContent = detectedFormation;
    }

    populateTeamFilter() {
        const teams = [...new Set(playersData.map(p => p['Team']).filter(Boolean))].sort();
        const teamFilter = document.getElementById('teamFilter');
        
        teams.forEach(team => {
            const option = document.createElement('option');
            option.value = team;
            option.textContent = team;
            teamFilter.appendChild(option);
        });
    }

    changeFormation(formationIndex) {
        this.currentFormation = this.formations[formationIndex];
        document.getElementById('formationDisplay').textContent = this.currentFormation.name;
        
        this.createFormation();
        this.createBenchSlots();
        this.redistributePlayers();
    }

    redistributePlayers() {
        if (selectedPlayers.length === 0) return;
        
        selectedPlayers.forEach(player => {
            if (player.slotElement) {
                this.removePlayerFromSlot(player.slotElement);
                player.slotElement = null;
            }
        });
        
        selectedPlayers.forEach(player => {
            const slot = this.findAvailableSlot(player.position, player.location);
            if (slot) {
                this.placePlayerInSlot(player, slot);
            }
        });
        
        this.updateTeamSummary();
    }

    filterPlayers() {
        const searchTerm = document.getElementById('playerSearch').value.toLowerCase();
        const positionFilter = document.getElementById('positionFilter').value;
        const teamFilter = document.getElementById('teamFilter').value;
        const rows = document.querySelectorAll('.player-row');

        rows.forEach(row => {
            const index = row.dataset.playerIndex;
            const player = playersData[index];
            
            let show = true;
            
            if (searchTerm) {
                const playerName = (player['Name'] || '').toLowerCase();
                const playerTeam = (player['Team'] || '').toLowerCase();
                show = show && (playerName.includes(searchTerm) || playerTeam.includes(searchTerm));
            }
            
            if (positionFilter) {
                const playerPosition = this.getPositionForSlot(player['Positions'] || '');
                show = show && playerPosition === positionFilter;
            }
            
            if (teamFilter) {
                show = show && player['Team'] === teamFilter;
            }
            
            row.style.display = show ? '' : 'none';
        });
    }

    bindEvents() {
        document.getElementById('autoFillTeam').addEventListener('click', () => this.autoFillTeam());
        document.getElementById('clearTeam').addEventListener('click', () => this.clearTeam());
        document.getElementById('saveTeam').addEventListener('click', () => this.showSaveModal());
        document.getElementById('loadTeam').addEventListener('click', () => this.showLoadModal());
        
        document.getElementById('budgetInput').addEventListener('input', (e) => {
            totalBudget = parseFloat(e.target.value) || 100.0;
            this.updateTeamSummary();
        });
        
        document.getElementById('weekSelect').addEventListener('change', (e) => {
            const week = e.target.value;
            const url = new URL(window.location);
            if (week) {
                url.searchParams.set('week', week);
            } else {
                url.searchParams.delete('week');
            }
            window.location.href = url.toString();
        });

        // Formation dropdown removed - formation adapts automatically to player swaps
        
        document.getElementById('playerSearch').addEventListener('input', () => this.filterPlayers());
        document.getElementById('positionFilter').addEventListener('change', () => this.filterPlayers());
        document.getElementById('teamFilter').addEventListener('change', () => this.filterPlayers());
        
        // Clear selection when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.player-card')) {
                this.clearSelection();
            }
        });

        // Close modals when clicking backdrop
        document.querySelectorAll('.custom-modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('show');
                }
            });
        });
    }
}

const draft = new DraftManager();
</script>
{% endblock %}